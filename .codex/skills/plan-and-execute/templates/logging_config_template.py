"""
Project logging configuration.

Generated by plan-and-execute install.sh.
Import and call setup_logging() once from your application entrypoint.

Configuration:
  destination: {{LOG_DEST}}
  format:      {{LOG_FORMAT}}
  level:       {{LOG_LEVEL}}

Usage:
    # In your app entrypoint (main.py, app.py, etc.):
    from logging_config import setup_logging
    setup_logging()

    # In every module:
    import logging
    logger = logging.getLogger(__name__)
    logger.info("Processing item: %s", item_name)
"""

import json
import logging
import logging.handlers
import os
import sys
from pathlib import Path

# --- Configuration (from project-config.yaml at install time) ---
LOG_DEST = "{{LOG_DEST}}"  # "terminal" | "file" | "both"
LOG_FILE_PATH = "{{LOG_FILE_PATH}}"  # relative to project root
LOG_ROTATION = "{{LOG_ROTATION}}"  # "size" | "time" | "none"
LOG_MAX_SIZE_MB = {{LOG_MAX_SIZE_MB}}
LOG_BACKUP_COUNT = {{LOG_BACKUP_COUNT}}
LOG_FORMAT = "{{LOG_FORMAT}}"  # "structured" | "human"
LOG_LEVEL = "{{LOG_LEVEL}}"  # "DEBUG" | "INFO" | "WARNING" | "ERROR"


class _JSONFormatter(logging.Formatter):
    """Structured JSON log formatter."""

    def format(self, record: logging.LogRecord) -> str:
        log_entry = {
            "timestamp": self.formatTime(record, self.datefmt),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
        }
        if record.exc_info and record.exc_info[0] is not None:
            log_entry["exception"] = self.formatException(record.exc_info)
        return json.dumps(log_entry)


_HUMAN_FORMAT = "%(asctime)s [%(levelname)-8s] %(name)s: %(message)s"


def _get_formatter() -> logging.Formatter:
    if LOG_FORMAT == "structured":
        return _JSONFormatter()
    return logging.Formatter(_HUMAN_FORMAT)


def _make_file_handler() -> logging.Handler:
    log_path = Path(LOG_FILE_PATH)
    log_path.parent.mkdir(parents=True, exist_ok=True)

    if LOG_ROTATION == "size":
        handler = logging.handlers.RotatingFileHandler(
            log_path,
            maxBytes=LOG_MAX_SIZE_MB * 1024 * 1024,
            backupCount=LOG_BACKUP_COUNT,
        )
    elif LOG_ROTATION == "time":
        handler = logging.handlers.TimedRotatingFileHandler(
            log_path,
            when="midnight",
            interval=1,
            backupCount=LOG_BACKUP_COUNT,
        )
    else:
        handler = logging.FileHandler(log_path)

    handler.setFormatter(_get_formatter())
    return handler


def setup_logging(level: str | None = None) -> None:
    """Configure project-wide logging. Call once from app entrypoint.

    Args:
        level: Override the default log level. If None, uses LOG_LEVEL from config.
    """
    root = logging.getLogger()
    root.setLevel(getattr(logging, level or LOG_LEVEL))

    # Clear any pre-existing handlers (avoid duplicate output on re-init)
    root.handlers.clear()

    if LOG_DEST in ("terminal", "both"):
        stream_handler = logging.StreamHandler(sys.stderr)
        stream_handler.setFormatter(_get_formatter())
        root.addHandler(stream_handler)

    if LOG_DEST in ("file", "both"):
        root.addHandler(_make_file_handler())
